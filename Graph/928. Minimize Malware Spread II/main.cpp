//
//  main.cpp
//  928. Minimize Malware Spread II
//
//  Created by 边俊林 on 2019/12/2.
//  Copyright © 2019 边俊林. All rights reserved.
//

#include <map>
#include <set>
#include <queue>
#include <string>
#include <stack>
#include <vector>
#include <cstdio>
#include <numeric>
#include <cstdlib>
#include <utility>
#include <iostream>
#include <algorithm>
#include <unordered_map>
#include <unordered_set>

using namespace std;

/// Solution:
//
// Solution 1: Simple BFS. time cost beats 50%
/*
 class Solution {
 public:
     int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
         int sz = graph.size();
         int res = 0, minn = INT_MAX;
         for (int init: initial) {
             queue<int> q;
             for (int tmpint: initial)
                 if (tmpint != init) q.push(tmpint);
             vector<bool> vis (sz, false);
             vis[init] = true;
             int cnt = 0;
             while (q.size()) {
                 int p = q.front(); q.pop();
                 if (vis[p]) continue;
                 vis[p] = true;
                 ++cnt;
                 for (int i = 0; i < sz; ++i)
                     if (i != p) q.push(i);
             }
             if (cnt < minn) {
                 minn = cnt;
                 res = init;
             }
         }
         return res;
     }
 };
 */


// Solution 2: Union-Find, time cost beats 40%
class Solution {
public:
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        int n = graph.size();
        int res = 0, minn = INT_MAX;
        sort(initial.begin(), initial.end());
        for (int i = 0; i < initial.size(); ++i) {
            UnionFind(n);
            vis = vector<bool> (n, false);
            for (int j = 0; j < n; ++j) {
                if (j == initial[i]) continue;
                for (int k = 0; k < n; ++k) {
                    if (k == initial[i] || k == j) continue;
                    if (graph[j][k] == 1)
                        Union(j, k);
                }
            }
            unordered_set<int> infs;
            for (int ini: initial)
                if (ini != initial[i]) infs.insert(Find(ini));
            int cnt = 0;
            for (int j = 0; j < n; ++j)
                if (j != initial[i] && infs.count(Find(j))) ++cnt;
            if (cnt < minn)
                res = initial[i], minn = cnt;

        }
        return res;
    }

private:
    vector<int> fa;
    vector<bool> vis;

    void UnionFind(int sz) {
        fa = vector<int> (sz, 0);
        for (int i = 0; i < sz; ++i)
            fa[i] = i;
    }

    bool Union(int u, int v) {
        int pu = Find(u);
        int pv = Find(v);
        if (pu == pv) return false;
        fa[pu] = fa[pv];
        return true;
    }

    int Find(int u) {
        if (fa[u] == u) return u;
        return fa[u] = Find(fa[u]);
    }
};

int main() {
    Solution sol = Solution();
    vector<vector<int>> g = {
//        {1,1,0},{1,1,0},{0,0,1}
//        {1,1,0},{1,1,1},{0,1,1}
//        {1,1,0,0},{1,1,1,0},{0,1,1,1},{0,0,1,1}
        {1,1,1,0},{1,1,0,0},{1,0,1,0},{0,0,0,1}
    };
    vector<int> ini = {
//        0, 1
        3, 2
    };
    int res = sol.minMalwareSpread(g, ini);
    cout << res << endl;
    return 0;
}
